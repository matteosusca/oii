\usepackage{xcolor}
\usepackage{afterpage}
\usepackage{pifont,mdframed}
\usepackage[bottom]{footmisc}


\createsection{\Grader}{Grader di prova}

\renewcommand{\inputfile}{\texttt{input.txt}}
\renewcommand{\outputfile}{\texttt{output.txt}}

\newenvironment{warning}
  {\par\begin{mdframed}[linewidth=2pt,linecolor=gray]%
    \begin{list}{}{\leftmargin=1cm
                   \labelwidth=\leftmargin}\item[\Large\ding{43}]}
  {\end{list}\end{mdframed}\par}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

{
\vspace{-1.75cm}\hfill\fbox{Difficoltà: 1}
}
\vspace{.5cm}


Luca e William devono sovente scambiarsi delle segretissime informazioni riguardo alle selezioni territoriali, sotto forma di numeri interi $N$. Per evitare di essere scoperti, hanno quindi deciso di inventare un nuovo codice crittografico, che hanno chiamato \emph{codice Luca-William-Fibonacci} (LWF).

In questo codice, ogni numero intero $N$ viene tradotto in una sequenza $s_0 s_1 \ldots s_k$ di cifre binarie \texttt{`0'} e \texttt{`1'}, di cui l'ultima \`e un \texttt{`1'}, in maniera tale che:
\[
N = \sum_{i=0}^{k} s_i \cdot F_i
\]
dove $F_i$ \`e il numero di Fibonacci $i$-esimo. Pi\`u informalmente, una cifra $1$ in posizione $i$ nella sequenza indica che il numero di Fibonacci $i$-esimo fa parte della somma che ricostruisce il numero $N$.

\begin{warning}
	La sequenza dei numeri di Fibonacci \`e definita in maniera \emph{ricorsiva}: i primi due termini della sequenza sono $F_0 = 1$ e $F_1 = 1$, mentre ognuno dei successivi viene calcolato sommando i due precedenti $F_{i} = F_{i-1} + F_{i-2}$.
\end{warning}

Per esempio, consideriamo la sequenza \texttt{1011001} di lunghezza $k = 7$. Visto che i primi $7$ numeri di Fibonacci sono:
\[
1 \quad 1 \quad 2 \quad 3 \quad 5 \quad 8 \quad 13
\]
il numero $N$ corrispondente \`e pari a $1 + 2 + 3 + 13 = 19$.

Luca ha gi\`a implementato l'algoritmo di decodifica (descritto come sopra), che da una sequenza di cifre binarie ricostruisce il numero $N$. Tuttavia William \`e ancora in alto mare con l'algoritmo di codifica, che dato un numero $N$ dovrebbe produrre una sequenza di cifre binarie corrispondente. Implementalo tu!

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %


\InputFile
Il file \inputfile{} è composto da un'unica riga contenente l'unico intero $N$.


\OutputFile
Il file \outputfile{} deve essere composto da un'unica riga contenente una sequenza di cifre binarie che termina con \texttt{`1'} corrispondente ad $N$.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %


\Constraints

\begin{itemize}[nolistsep, itemsep=2mm]
	\item $1 \le N \le 1\,000\,000$.
	\item Potrebbero esserci pi\`u sequenze di cifre ugualmente valide.
\end{itemize}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %


\Examples

\begin{example}
\exmpfile{lwf.input0.txt}{lwf.output0.txt}%
\exmpfile{lwf.input1.txt}{lwf.output1.txt}%
\end{example}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %


\Explanation

Il \textbf{primo caso di esempio} \`e quello discusso nel testo.\\[2mm]
Nel \textbf{secondo caso di esempio}, $9$ pu\`o essere ottenuto sia come $1+1+2+5$ (come nell'output di esempio), oppure come $1+3+5$ (\texttt{10011}) e $1+8$ (\texttt{100001}).

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

%\newpage
%\begin{solution}
%    \input{extra_tecla/soluzione}
%\end{solution}
